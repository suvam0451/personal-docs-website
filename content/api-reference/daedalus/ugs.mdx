---
path: "/api/daedalus/gameplay-systems"
title: "Instanced Static Meshes in UE4 (Part 1/3)"
date: "2020-01-10"
submoduleID: 1
seriesID: 2
seriesIndex: 1
draft: false
---

<Alert
	head="Invocation Tradeoff"
	body="Unlike snippets, If you use Commandlets, missing headers are automatically injected."
/>

## ugs : Snippet/Commandlet namespace

This namespace(gameplay systems) contains snippets and commandlets to let us interact with following

- UGameplayStatics class
- Dealing with DataTable
- Dealing with AssetRegistry

<Alert
	head="Why the fancy shorthand names ?"
	body="Similar/same name confuse intellisense. Short-hand macros are typed fast and suggested early."
/>

---

### UGameplayStatics methods

[GampleplayStatics](https://docs.unrealengine.com/en-US/API/Runtime/Engine/Kismet/UGameplayStatics/index.html) has gameplay utility functions.
This plug-in provides utility access to the most useful functions.
If you feel a useful method was left-out, please let me know.

#### ugs_objectfind

Used to load assets by path in C++ code. Try not to load assets directly in C++ like this(except data assets). There are better options available.

- **\$1**: Pick a decent(disposable) name for object.
- **\$2**: Location of asset (See extra info).
- **\$3**: Object type
- **\$4**: Where to cast after null-check (If you skip null-check and don't get reference, a warning will be thrown).

```cpp
static ConstructorHelpers::FObjectFinder<${3:UStaticMesh}> ${1:UniqueName}(TEXT("/Game/$2"));
if(${1:UniqueName} != null) {
    ${4:TargetObject} = ${1:UniqueName}.Object;
}
```

[More...](/api/daedalus/gameplay-systems/ugs_objectfind)

#### ugs_classfind

Used to load classes. **_Importantly, this is one of few ways to load BP classes into C++._**

- **\$1**: Name for object _(temporary)_.
- **\$2**: Location of asset _(See notes)_.
- **\$3**: TargetClass _(or its ParentClass)_
- **\$4**: Target _(See notes)_.

```cpp
static ConstructorHelpers::FClassFinder<${3:ParentClass}> ${1:UniqueName}(TEXT("/Game/$2"));
if(${1:UniqueName} != null) {
    ${4:TargetSubClassOf} = ${1:UniqueName}.Class;
}
```

- We need both a null check and a cast check.
- **\$4** may be defined in header as `TSubClassOf<ACharacter>`
- You can cast the output to a child class of ParentClass _(once again, don't neglect the checks)_.
- (If you skip null-check and don't get reference, a warning will be thrown)
